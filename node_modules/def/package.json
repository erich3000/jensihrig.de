{
  "author": {
    "name": "Brandon Benvie",
    "email": "brandon@bbenvie.com",
    "url": "http://bbenvie.com"
  },
  "name": "def",
  "description": "A JavaScript library for creating complex objects and properties, intuitively.",
  "keywords": [
    "ecmascript",
    "language",
    "properties",
    "definition",
    "define"
  ],
  "version": "0.0.8",
  "homepage": "https://github.com/Benvie/def",
  "repository": {
    "type": "git",
    "url": "https://github.com/Benvie/def"
  },
  "main": "index.js",
  "engines": {
    "node": "*"
  },
  "dependencies": {},
  "devDependencies": {},
  "readme": "# define def\nA single function to make defining sets of properties simple.\n\n\n## Basic Usage\nYou can use def in two ways. The first using the target object as a parameter\n\n    var define = require('def').define;\n    define(myObject, properties);\n\nThe second allows you to attach it to an object for self-defining. This is useful when used on prototypes for imbuing the ability to easily define properties on objects inheriting from it.\n\n    var def = require('def');\n    def.attach(myObject.prototype);\n\n    // or expose it to all objects\n    def.attach(Object.prototype);\n\nThen it should be used directly on the target object which should have the properties, whether that object will be used as a prototype or a singleton.\n\n\n### named function only\n\n    myObj.def(function namedFunction(){});\n     // -> //gets name from function itself, can only be named in source or with eval, not dynamic\n      { namedFunction: Function namedFunction }\n\n### property name and any value\n\n    myObj.def('myProp', 5000);\n     // -> // simple property, config/enum/write = true\n      { myProp: 5000 }\n\n### getter/setter non-backward compatible syntax\n\n    myObj.def({\n      get myProp(){ return 5000; },\n      set myProp(val){ 'some setter logic'; }\n    });\n     // ->\n      { myProp: [Getter/Setter] }\n\n\n## Controlling enumerable, writable, configurable\n\n\n### non-enumerable\n\n    myObj.def('_hiddenProp', 'somevalue');\n     // -> //non-enumerable, invisible unless you use getOwnPropertyNames, '_' sliced\n      { [hiddenProp]: 'somevalue' }\n\n### non-configurable\n\n    myObj.def(function $superImportantFunction(){});\n     // -> //non-configurable (no delete or redefine), '$' sliced\n      { [superImportantFunction]: Function $superImportantFunction }\n\n### non-writable\n\n    myObj.def('SOMECONSTANT', 'this value is constant');\n     // -> //non-writable (can still be changed using configurability, AKA delete and redefine)\n      { SOMECONSTANT: 'this value is constant' }\n\n\n## Multiple properties\n\n\n### dict\n\n    myObj.def({\n      property1: 'simpleValue',\n      get prop2(){ return 'get/setter using non-backcompat syntax' },\n      set prop2(val){ this.powerLevel = 9001; },\n      _someFunc: function(){ console.log(\"can't effectively use named functions with a dict =(\") }\n    });\n     // ->\n      { property1: 'simplValue',\n        prop2: [Getter/Setter],\n        [someFunc]: Function }\n\n### array of named functions\n\n    myObj.def([\n      function firstFunction(){ console.log('whatever:' + this); },\n      function getSecrets(){ return getSecretsFromDB('teehee'); },\n      function setSecrets(val){ sendSecretsToDB(val); },\n      function _stealSecretsForBlackMarket(){ return getAllSecretsFromDB_unlogged(); },\n    ]);\n     // ->\n      { firstFunction: Function firstFunction,\n        Secrets: [Getter/Setter],\n        [stealSecretsForBlackMarket]: Function _stealSecretsForBlackMarket }\n\n\n## Private variables\n\nPrivate values are detected by the existence of an extra parameter on the get or set functions. These aren't valid getters and setters to JavaScript but they will be wrapped such that they share a private value inaccessible from anywhere else, but shared between the getter and setter functions. The private value is passed in each time, along with the passed in value for setters.\n\n\n### simple private usage\n    myObj.def({\n      myPrivate: {\n        get: function(privateValue){\n          return privateValue;\n        },\n        set: function(privateValue, newValue){\n          return newValue; // privateValue is set to whatever `set` returns\n        }\n      }\n    })\n\n### advanced private usage\n    myObj.def({\n      myPrivate: {\n        get: function(privateValue){\n          return privateValue.somePublicProperty;\n        },\n        set: function(privateValue, newValue){\n          if (newValue.secreyKey === privateValue.unlockKey)\n            return newValue.newPublicProperty;\n          } else {\n            return privateValue.somePublicProperty;\n          }\n        }\n      }\n    })\n\n\n## Match Arguments to parameters\nUse the named parameters of a function to match arguments to what they should be named.\n\n### function\n\n    function RGB(red, green, blue){\n      return define({}, RGB, arguments);\n    }\n\n    var red = RGB(255, 0, 0);\n     // ->\n      { red: 255,\n        green: 0,\n        blue: 0 }\n\n### constructor\n\n    function RGB(r, g, b){\n      this.define(arguments);\n    }\n\n    RGB.prototype = def.attach({}).define({\n      constructor: RGB,\n      toHex: someToHexFunction\n    });\n\n    var fuschia = new RGB(255, 0, 255);\n     // ->\n      { r: 255,\n        g: 0,\n        b: 255 }",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Benvie/def/issues"
  },
  "_id": "def@0.0.8",
  "dist": {
    "shasum": "3af9917c61288740635e1b3e036014e01268a6d0"
  },
  "_from": "def@",
  "_resolved": "https://registry.npmjs.org/def/-/def-0.0.8.tgz"
}
